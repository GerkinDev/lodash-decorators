{"version":3,"file":"flip.js","sourceRoot":"","sources":["../../src/flip.ts"],"names":[],"mappings":";;;;AAAA,kEAA+B;AAE/B,qCAKmB;AACnB,6CAAuD;AAEvD,IAAM,SAAS,GAAG,0BAAgB,CAAC,uBAAuB,CACxD,IAAI,yBAAe,CAAC,cAAI,EAAE,IAAI,oCAAsB,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC,CAC5E,CAAC;AAEF;;;;;;;;;;;;;;;;;;;;GAoBG;AACH,SAAgB,IAAI,CAAC,EAAuB;IAC1C,OAAO,SAAS,CAAC,EAAE,CAAC,CAAC;AACvB,CAAC;AAFD,oBAEC;AACgB,oBAAI;AACrB,kBAAe,SAAS,CAAC","sourcesContent":["import flip from 'lodash/flip';\n\nimport {\n  DecoratorConfig,\n  DecoratorFactory,\n  LodashDecorator,\n  ResolvableFunction\n} from './factory';\nimport { PartialValueApplicator } from './applicators';\n\nconst decorator = DecoratorFactory.createInstanceDecorator(\n  new DecoratorConfig(flip, new PartialValueApplicator(), { property: true })\n);\n\n/**\n * Creates a function that invokes func with arguments reversed. Honestly, there is probably not much\n * use for this decorator but maybe you will find one?\n *\n * @example\n *\n * class MyClass {\n *   value = 100;\n *\n *   @Flip('fn')\n *   fn2: (b: number, a: string) => [ number, string ];\n *\n *   fn(a: string, b: number): [ string, number ] {\n *     return [ a, b ];\n *   }\n * }\n *\n * const myClass = new MyClass();\n *\n * myClass.fn2(10, '20'); // => [ '20', 10 ]\n */\nexport function Flip(fn?: ResolvableFunction): LodashDecorator {\n  return decorator(fn);\n}\nexport { Flip as flip };\nexport default decorator;\n"]}